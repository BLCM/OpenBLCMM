/*
 * Copyright (C) 2018-2020  LightChaosman
 *
 * BLCMM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 * Additional permission under GNU GPL version 3 section 7:
 *
 * If you modify this Program, or any covered work, by linking or
 * combining it with BLCMM Launcher, BLCMM Lib Distributor, BLCMM
 * Resources, or BLCMM Utilities (or modified versions of those
 * libraries), containing parts covered by the terms of their
 * proprietary license, the licensors of this Program grant you
 * additional permission to convey the resulting work.
 *
 */
package blcmm.gui.panels;

import blcmm.gui.MainGUI;
import blcmm.gui.components.EnhancedFormattedTextField;
import blcmm.utilities.GlobalLogger;
import java.awt.Component;
import java.awt.Dialog;
import java.awt.EventQueue;
import java.awt.Window;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.OptionalInt;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.IntStream;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.WindowConstants;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;

/**
 *
 * @author FromDarkHell initial functionality
 * @author LightChaosman replacement & regex
 */
public class TextSearchDialog extends javax.swing.JDialog {

    private String previous = "";
    public JTextComponent textcomp;

    public TextSearchDialog(Window parent, JTextComponent textcomponent, String previousSearch) {
        this(parent, textcomponent, previousSearch, true);
    }

    /**
     * Creates new form TextSearchDialog
     *
     * @param parent The parent window which we belong to
     * @param textcomponent The text component we read the text from.
     * @param previousSearch The previousSearch so we can update it.
     * @param replace true iff replace UI elements should be shown
     */
    public TextSearchDialog(Window parent, JTextComponent textcomponent, String previousSearch, boolean replace) {
        super(parent);
        super.setModalityType(Dialog.ModalityType.MODELESS);
        this.textcomp = textcomponent;
        this.previous = previousSearch;
        super.setIconImages(MainGUI.INSTANCE.getIconImages());
        super.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        initComponents();
        if (!replace) {
            replaceTextField.setVisible(false);
            replaceLabel.setVisible(false);
            replaceAllButton.setVisible(false);
            replaceButton.setVisible(false);
        }

        findPreviousButton.setFont(findPreviousButton.getFont().deriveFont(findPreviousButton.getFont().getSize2D() + 2f));
        findNextButton.setFont(findNextButton.getFont().deriveFont(findNextButton.getFont().getSize2D() + 2f));

        // A keyAdapter to read for an Enter key and then do a Find Next
        KeyAdapter keyAdapater = new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    searchButtonAction(e.isShiftDown());
                } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                    dispose();
                }
            }
        };
        super.addKeyListener(keyAdapater);
        searchTextField.addKeyListener(keyAdapater);

        // WindowListener to refocus our textarea if we're closed
        super.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosed(WindowEvent e) {
                if (textcomp != null && textcomp.isDisplayable()) {
                    textcomp.requestFocus();
                }
            }
        });

        super.setLocationRelativeTo(parent);
        searchTextField.requestFocus();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        cancelButton = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        wrapAroundCheckBox = new javax.swing.JCheckBox();
        matchCaseCheckBox = new javax.swing.JCheckBox();
        regularExpressionCheckBox = new javax.swing.JCheckBox();
        jPanel2 = new javax.swing.JPanel();
        replaceAllButton = new javax.swing.JButton();
        replaceButton = new javax.swing.JButton();
        findPreviousButton = new javax.swing.JButton();
        findNextButton = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        searchLabel = new javax.swing.JLabel();
        replaceLabel = new javax.swing.JLabel();
        replaceTextField = new javax.swing.JTextField();
        searchTextField = new EnhancedFormattedTextField<>(this::isValidRegex, s->s);
        statusLabel = new javax.swing.JLabel(){public void setText(String text){if(!text.toLowerCase().startsWith("<thml>")){text = "<html>"+text;}super.setText(text);}};

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Search");

        cancelButton.setText("Cancel");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });

        wrapAroundCheckBox.setSelected(true);
        wrapAroundCheckBox.setText("Wrap around");

        matchCaseCheckBox.setText("Match case");

        regularExpressionCheckBox.setText("Regular expression");
        regularExpressionCheckBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                regularExpressionCheckBoxItemStateChanged(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(wrapAroundCheckBox)
            .addComponent(matchCaseCheckBox)
            .addComponent(regularExpressionCheckBox)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(regularExpressionCheckBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(matchCaseCheckBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(wrapAroundCheckBox))
        );

        replaceAllButton.setText("Replace all");
        replaceAllButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                replaceAllButtonActionPerformed(evt);
            }
        });

        replaceButton.setText("Replace");
        replaceButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                replaceButtonActionPerformed(evt);
            }
        });

        findPreviousButton.setFont(new java.awt.Font("Calibri", 1, 12)); // NOI18N
        findPreviousButton.setText("←");
        findPreviousButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findPreviousButtonActionPerformed(evt);
            }
        });

        findNextButton.setFont(new java.awt.Font("Calibri", 1, 12)); // NOI18N
        findNextButton.setText("→");
        findNextButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findNextButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(replaceAllButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(findPreviousButton, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(findNextButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(replaceButton, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(findNextButton)
                    .addComponent(findPreviousButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(replaceButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(replaceAllButton))
        );

        searchLabel.setText("Search For:");

        replaceLabel.setText("Replace with:");

        replaceTextField.setPreferredSize(new java.awt.Dimension(14, 32));

        searchTextField.setPreferredSize(new java.awt.Dimension(14, 32));

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                        .addComponent(replaceLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(searchLabel)
                        .addGap(17, 17, 17)))
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(searchTextField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(replaceTextField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(searchTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(searchLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(replaceTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(replaceLabel)))
        );

        statusLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        statusLabel.setVerticalAlignment(javax.swing.SwingConstants.BOTTOM);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(statusLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 245, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cancelButton, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(cancelButton))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(statusLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap())
        );

        getAccessibleContext().setAccessibleName("Find");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void findNextButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findNextButtonActionPerformed
        searchButtonAction(false);
    }//GEN-LAST:event_findNextButtonActionPerformed

    private void findPreviousButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findPreviousButtonActionPerformed
        searchButtonAction(true);
    }//GEN-LAST:event_findPreviousButtonActionPerformed

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        this.dispose();
    }//GEN-LAST:event_cancelButtonActionPerformed

    private void replaceButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_replaceButtonActionPerformed
        String search = searchTextField.getText();
        String replacement = replaceTextField.getText();
        if (!isRegex()) {
            Range range = search(false, textcomp.getCaret().getDot(), true, true, isRegex());
            if (range.offset != -1) {
                try {
                    textcomp.getDocument().remove(range.offset, range.length);
                    textcomp.getDocument().insertString(range.offset, replacement, null);
                    selectInDocument(range.offset, replacement.length());
                    statusLabel.setText("");
                } catch (BadLocationException ex) {
                    //Should never happen, by contract of our search method
                }
            } else {
                displayNoResultsMessage();
            }
        } else {
            try {
                Pattern p = Pattern.compile(search, isMatchCase() ? 0 : Pattern.CASE_INSENSITIVE);

                int start = textcomp.getSelectionStart();
                String full = textcomp.getText();
                String head = full.substring(0, start);
                String tail = full.substring(start);
                StringBuffer builder = new StringBuffer();
                Matcher matcher = p.matcher(tail);
                String pre, post;
                int startOfReplacement = -1, endOfReplacement = -1;
                if (matcher.find()) {
                    builder.append(head);
                    startOfReplacement = builder.length() + matcher.start();
                    pre = matcher.group();
                    matcher.appendReplacement(builder, replacement);
                    endOfReplacement = builder.length();
                    post = builder.substring(startOfReplacement, endOfReplacement);
                    matcher.appendTail(builder);
                } else if (isWrapAround()) {
                    matcher = p.matcher(full);
                    if (matcher.find()) {
                        startOfReplacement = builder.length() + matcher.start();
                        pre = matcher.group();
                        matcher.appendReplacement(builder, replacement);
                        endOfReplacement = builder.length();
                        post = builder.substring(startOfReplacement, endOfReplacement);
                        matcher.appendTail(builder);
                    }
                }
                if (builder.length() != 0) {
                    textcomp.setText(builder.toString());
                    selectInDocument(startOfReplacement, endOfReplacement - startOfReplacement);
                    statusLabel.setText("");
                } else {
                    displayNoResultsMessage();
                }
            } catch (java.util.regex.PatternSyntaxException e) {
                displayRegexMessage(e);
            }
        }
    }//GEN-LAST:event_replaceButtonActionPerformed

    private void replaceAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_replaceAllButtonActionPerformed
        String search = searchTextField.getText();
        String replacement = replaceTextField.getText();
        if (!isRegex()) {
            List<Range> ranges = new ArrayList<>();
            Range cur = new Range(0, 0);
            while ((cur = search(false, cur.offset, false, false, isRegex())).offset != -1) {
                ranges.add(cur);
                cur = new Range(cur.offset + search.length(), 0);
            } //process the offsets backwards, so edits don't influence other results.
            for (int i = ranges.size() - 1; i >= 0; i--) {
                try {
                    Range range = ranges.get(i);
                    textcomp.getDocument().remove(range.offset, range.length);
                    textcomp.getDocument().insertString(range.offset, replacement, null);
                } catch (BadLocationException ex) {
                    //Should never happen, by contract of our search method
                }
            }
            if (ranges.size() > 0) {
                statusLabel.setText("Replaced " + ranges.size() + " instances of '" + search + "' by '" + replacement + "'.");
            } else {
                displayNoResultsMessage();
            }
        } else {
            try {
                Pattern p = Pattern.compile(search, isMatchCase() ? 0 : Pattern.CASE_INSENSITIVE);
                Matcher matcher = p.matcher(textcomp.getText());
                int count = 0;
                StringBuffer builder = new StringBuffer();
                while (matcher.find()) {
                    matcher.appendReplacement(builder, replacement);
                    count++;
                }
                if (count > 0) {
                    matcher.appendTail(builder);
                    textcomp.setText(builder.toString());
                    statusLabel.setText("Replaced " + count + " instances of '" + search + "' by '" + replacement + "'.");
                } else {
                    displayNoResultsMessage();
                }
            } catch (java.util.regex.PatternSyntaxException e) {
                displayRegexMessage(e);
            }

        }

    }//GEN-LAST:event_replaceAllButtonActionPerformed

    private void regularExpressionCheckBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_regularExpressionCheckBoxItemStateChanged
        ((EnhancedFormattedTextField) searchTextField).updateTooltip();
    }//GEN-LAST:event_regularExpressionCheckBoxItemStateChanged

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cancelButton;
    private javax.swing.JButton findNextButton;
    private javax.swing.JButton findPreviousButton;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JCheckBox matchCaseCheckBox;
    private javax.swing.JCheckBox regularExpressionCheckBox;
    private javax.swing.JButton replaceAllButton;
    private javax.swing.JButton replaceButton;
    private javax.swing.JLabel replaceLabel;
    private javax.swing.JTextField replaceTextField;
    private javax.swing.JLabel searchLabel;
    private javax.swing.JTextField searchTextField;
    private javax.swing.JLabel statusLabel;
    private javax.swing.JCheckBox wrapAroundCheckBox;
    // End of variables declaration//GEN-END:variables

    public void updateTextComponent(JTextComponent textComp) {
        this.textcomp = textComp;
    }

    private Range search(boolean searchPrevious) {
        return search(searchPrevious, textcomp.getCaret().getDot(), false, isWrapAround(), isRegex());
    }

    private Range search(
            boolean searchBackwards,
            int initialIndex,
            boolean includeCurrentResult,//If true, and initialIndex is at the *end* of a match, initialIndex will be returned
            //This is used for non-regex `replace`, so you can find first, then replace
            boolean wrapAround,
            boolean regex) {
        String search = searchTextField.getText();
        if (search != null && !search.isEmpty()) {
            try {
                // This is the text we're searching in, say an object dump
                String text = textcomp.getDocument().getText(0, textcomp.getDocument().getLength());
                if (!isMatchCase()) {
                    text = text.toLowerCase();
                    search = search.toLowerCase();
                }
                this.previous = search;
                if (!regex) {
                    if (includeCurrentResult && initialIndex >= search.length()
                            && text.substring(initialIndex - search.length(), initialIndex).equals(search)) {
                        return new Range(initialIndex, search.length());
                    }
                    int offset = searchBackwards
                            ? text.lastIndexOf(search, initialIndex - search.length() - 1)
                            : text.indexOf(search, initialIndex);
                    if (offset == -1 && wrapAround) {
                        if (searchBackwards) {
                            //Just search from the end
                            offset = text.lastIndexOf(search);
                        } else {
                            //Just search from the start
                            offset = text.indexOf(search);
                        }
                        if (offset == initialIndex) {
                            //There is just 1 result, and we're already there
                            offset = -1;
                        }
                    }
                    return new Range(offset, search.length());
                } else {//Regex search
                    Pattern p = Pattern.compile(search);

                    Matcher matcher = p.matcher(text);
                    //Both for backwards searching and checking if we're already at a result, we need to scan the whole text.
                    //Might as well do it in all cases, to keep the code clean
                    List<Range> res = new ArrayList<>();
                    while (matcher.find()) {
                        res.add(new Range(matcher.start(), matcher.end() - matcher.start()));
                    }
                    if (res.isEmpty()) {
                        return new Range(-1, 0);
                    }
                    OptionalInt opt = IntStream.range(0, res.size()).filter(i -> res.get(i).offset < initialIndex).max();
                    int idxToCheck = opt.isPresent() ? opt.getAsInt() : 0;
                    Range r = res.get(idxToCheck);
                    if (r.offset + r.length == initialIndex && includeCurrentResult) {
                        return r;
                    } else if (searchBackwards) {
                        for (int j = idxToCheck; j >= 0; j--) {
                            r = res.get(j);
                            assert r.offset < initialIndex;
                            if (r.offset + r.length < initialIndex) {
                                return r;
                            }
                        }
                    } else {
                        for (int j = idxToCheck; j < res.size(); j++) {
                            r = res.get(j);
                            if (r.offset >= initialIndex) {
                                return r;
                            }
                        }
                    }
                    if (wrapAround) {
                        if (searchBackwards) {
                            return res.get(res.size() - 1);
                        }
                        return res.get(0);
                    }
                    return new Range(-1, 0);

                }

            } catch (BadLocationException ex) {
                GlobalLogger.log("Got a bad location exception while searching: " + ex.toString());
                //never? happens
            } catch (StringIndexOutOfBoundsException ex) {
                GlobalLogger.log(ex);
                // Happens on an empty dump with previous search, do nothing for now
            }
        }
        return new Range(-1, -1);
    }

    private void selectInDocument(Range r) {
        selectInDocument(r.offset, r.length);
    }

    private void selectInDocument(final int offset, final int length) {
        textcomp.setCaretPosition(offset);
        EventQueue.invokeLater(() -> {//We do this bit later, so the viewport scrolls to the start of our match first
            textcomp.setSelectionStart(offset);//And then, select the thing
            textcomp.setSelectionEnd(offset + length);
        });
        //Now some magic to get stuff to focus properly
        final Component curFocus = this.getFocusOwner();
        if (SwingUtilities.getWindowAncestor(textcomp).getFocusOwner() != textcomp) {
            EventQueue.invokeLater(() -> {
                textcomp.requestFocus(true);//Get the focus to the text element
                EventQueue.invokeLater(() -> curFocus.requestFocus());//Later, get it back to us
            });

        }
    }

    private boolean isWrapAround() {
        return wrapAroundCheckBox.isSelected();
    }

    private boolean isMatchCase() {
        return matchCaseCheckBox.isSelected();
    }

    private boolean isRegex() {
        return regularExpressionCheckBox.isSelected();
    }

    private void searchButtonAction(boolean backwards) {
        try {
            Range res = search(backwards);
            if (res.offset != -1) {
                selectInDocument(res);
                statusLabel.setText("");
            } else {
                displayNoResultsMessage();
            }
        } catch (PatternSyntaxException e) {
            displayRegexMessage(e);
        }
    }

    private void displayNoResultsMessage() {
        statusLabel.setText("No results for '" + searchTextField.getText() + "'");
    }

    private void displayRegexMessage(PatternSyntaxException e) {
        JOptionPane.showMessageDialog(this,
                "Your regular expression could not be parsed\n\n"
                + e.getMessage(),
                "Faulty regular expression", JOptionPane.ERROR_MESSAGE);
    }

    private String isValidRegex(String arg) {
        if (!isRegex()) {
            return null;
        }
        try {
            Pattern p = Pattern.compile(arg);
            return null;
        } catch (PatternSyntaxException e) {
            return e.getMessage();
        }
    }

    @Override
    public void requestFocus() {
        super.requestFocus();
        searchTextField.requestFocus();
    }

    private static class Range {

        int offset, length;

        public Range(int offset, int length) {
            this.offset = offset;
            this.length = length;
        }

        @Override
        public String toString() {
            return "(" + offset + " " + length + ")";
        }

    }

}
